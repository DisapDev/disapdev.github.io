<!doctype html>
<html lang="en">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Google+Sans+Flex:opsz,wght@6..144,1..1000&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

<style>
.google-sans-flex-normal {
  font-family: "Google Sans Flex", sans-serif;
  font-optical-sizing: auto;
  font-weight: 400;
  font-style: normal;
  font-variation-settings:
    "slnt" 0,
    "wdth" 100,
    "GRAD" 0,
    "ROND" 0;
}
</style>

<head>
  <title>Model Inspector</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; font-family: "Google Sans Flex", sans-serif; background: #222; }
    
    /* Sidebar for Hierarchy */
    #sidebar {
      position: absolute; top: 0; left: 0; width: 250px; height: 100%;
      background: #1a1a1a; border-right: 1px solid #444;
      overflow-y: auto; color: #ddd; z-index: 10;
      display: flex; flex-direction: column;
    }
    #sidebar-resize-handle {
      position: absolute; right: -4px; top: 0; width: 8px; height: 100%;
      cursor: col-resize; background: transparent;
      z-index: 100;
    }
    #sidebar-resize-handle:hover {
      background: #00D2FF;
    }
    .header { 
      padding: 15px 15px 0 15px; background: #111; font-weight: bold; border-bottom: 1px solid #444;
      flex-shrink: 0;
    }
    .header-title {
      margin-bottom: 12px;
    }
    #phase-controls {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 10px;
    }
    #tree-container {
      flex: 1; overflow-y: auto;
    }
    .tree-item { 
      padding: 8px 15px; cursor: pointer; font-size: 14px; border-bottom: 1px solid #333;
      display: flex; align-items: center; gap: 8px;
      user-select: none;
    }
    .tree-item:hover { background: #333; }
    .tree-item.selected { background: #00D2FF; color: black; }
    .tree-item.hidden { opacity: 0.5; }
    .expand-btn {
      width: 20px; text-align: center; flex-shrink: 0;
      cursor: pointer;
      font-size: 12px;
    }
    .expand-btn.collapsed::before { content: '‚ñ∂'; }
    .expand-btn.expanded::before { content: '‚ñº'; }
    .expand-btn.no-children::before { content: ''; }
    .visibility-btn {
      width: 20px; text-align: center; flex-shrink: 0;
      cursor: pointer;
      font-size: 14px;
      margin-left: auto;
    }
    .visibility-btn.visible::before { content: 'üëÅ'; }
    .visibility-btn.hidden::before { content: 'üö´'; }

    /* Floating Data Panel */
    #data-panel {
      position: absolute; top: 20px; right: 20px; z-index: 10;
      background: rgba(20, 20, 20, 0.95); border: 1px solid #444;
      border-radius: 8px; padding: 16px; max-width: 320px;
      color: #ddd; font-size: 13px; max-height: 400px;
      overflow-y: auto; font-family: "Google Sans Flex", sans-serif;
      box-shadow: 0 4px 15px rgba(0,0,0,0.7);
    }
    #data-panel h3 {
      margin: 0 0 12px 0; color: #ffffff; font-size: 14px; font-weight: bold;
    }
    #data-panel .section {
      margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #333;
    }
    #data-panel .section:last-child {
      border-bottom: none; margin-bottom: 0; padding-bottom: 0;
    }
    #data-panel .label {
      color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    #data-panel .value {
      color: #ffffff; word-break: break-word; line-height: 1.4;
    }
    #data-panel-empty {
      color: #666; font-style: italic;
    }

    /* Action Bar */
    #actions {
      position: absolute; bottom: 20px; right: 20px; z-index: 10;
      display: flex; gap: 10px;
    }
    .ar-btn {
      background: white; border: none; padding: 12px 24px;
      font-weight: bold; border-radius: 30px; cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5); text-decoration: none; color: black;
    }
    .ar-btn:hover { transform: scale(1.05); }
  </style>

  <!-- Import Map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>

  <!-- Sidebar UI -->
  <div id="sidebar">
    <div id="sidebar-resize-handle"></div>
    <div class="header">
      <div class="header-title">üìÅ Project Hierarchy</div>
      <div id="phase-controls">
        <label for="phase-slider" style="font-size:12px; color:#ccc;">Phase:</label>
        <input id="phase-slider" type="range" min="0" max="0" value="0" style="width:120px;">
        <span id="phase-label" style="font-size:12px; color:#ccc; min-width:36px; text-align:right;"></span>
      </div>
    </div>
    <div id="tree-container">Loading...</div>
  </div>

  <!-- Floating Data Panel -->
  <div id="data-panel">
    <div id="data-panel-empty">Select an object to view details</div>
  </div>

  <!-- Launch AR Buttons -->
  <div id="actions">
    <a id="btn-hit-test" href="#" class="ar-btn">üöÄ AR Hit-Test (Unavailable) </a>
    <a id="btn-marker" href="#" class="ar-btn">üñºÔ∏è AR Marker (Unavailable) </a>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { getModelID, getPaths, loadProjectManifest } from '../js/project-loader.js';

    // 1. Get ID and Setup Links
    const modelID = getModelID();
    if (!modelID) { alert("No Model ID specified!"); window.location.href = "../index.html"; }

    // Update AR buttons to pass the ID forward
    document.getElementById('btn-hit-test').href = `hit-test.html?id=${modelID}`;
    document.getElementById('btn-marker').href = `marker.html?id=${modelID}`;

    // 2. Three.js Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x333333);
    
    const camera = new THREE.PerspectiveCamera(60, (window.innerWidth - 250) / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.sortObjects = true;
    renderer.setSize(window.innerWidth - 250, window.innerHeight); // Subtract sidebar width
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.left = '250px'; // Move canvas right
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.autoRotate = true; // Enable auto rotation by default
    controls.autoRotateSpeed = 2; // Rotation speed
    controls.minDistance = 1;
    controls.maxDistance = 100;
    controls.enableZoom = true;
    controls.enableRotate = true;
    controls.mouseButtons = {
      LEFT: THREE.MOUSE.ROTATE,
      MIDDLE: THREE.MOUSE.DOLLY,
      RIGHT: THREE.MOUSE.PAN
    };
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    };
    controls.panSpeed = 2.0; // Increase pan sensitivity
    
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(5, 10, 7);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    
    // Add additional lights for better default illumination
    const frontLight = new THREE.DirectionalLight(0xffffff, 1);
    frontLight.position.set(-5, 5, 5);
    scene.add(frontLight);
    
    const backLight = new THREE.PointLight(0x888888, 1);
    backLight.position.set(0, -5, -10);
    scene.add(backLight);

    // Load HDR Environment Map
    const rgbeLoader = new RGBELoader();
    rgbeLoader.load('../assets/sunny_rose_garden_2k.hdr', (texture) => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture;
        scene.background = texture;
    });

    // 3. Load Logic
    const loader = new GLTFLoader();
    const paths = getPaths(modelID);
    const treeContainer = document.getElementById('tree-container');

    // Track visibility state and DOM refs for objects
    const visibilityState = new WeakMap();
    const domMap = new Map(); // uuid -> { div, visBtn, expandBtn }
    
    // Raycasting and selection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedObject = null;
    const outlineObjects = new Set(); // Track objects with outline

    // Add single item to sidebar and store refs
    function addToSidebar(name, object, indent = 0, parentUuid = null) {
      const div = document.createElement('div');
      div.className = 'tree-item';
      div.style.paddingLeft = (15 + indent * 20) + 'px';
      div.dataset.uuid = object.uuid;
      if (parentUuid) div.dataset.parent = parentUuid;

      visibilityState.set(object, true);

      let icon = 'üì¶';
      if (object.isMesh) icon = 'üî∑';
      else if (object.isGroup) icon = 'üìÅ';

      const expandBtn = document.createElement('span');
      expandBtn.className = 'expand-btn no-children';

      const label = document.createElement('span');
      label.textContent = icon + ' ' + name;

      const visBtn = document.createElement('span');
      visBtn.className = 'visibility-btn visible';
      visBtn.title = 'Toggle visibility';
      visBtn.onclick = (e) => {
        e.stopPropagation();
        const isVisible = visibilityState.get(object);
        visibilityState.set(object, !isVisible);
        object.visible = !isVisible;
        visBtn.classList.toggle('hidden');
        visBtn.classList.toggle('visible');
        if (!isVisible) div.classList.remove('hidden'); else div.classList.add('hidden');
      };

      expandBtn.onclick = (e) => {
        e.stopPropagation();
        const isCollapsed = expandBtn.classList.toggle('collapsed');
        if (isCollapsed) expandBtn.classList.remove('expanded'); else expandBtn.classList.add('expanded');
        toggleChildren(object.uuid, isCollapsed);
      };

      div.appendChild(expandBtn);
      div.appendChild(label);
      div.appendChild(visBtn);

      div.addEventListener('click', (e) => {
        if (e.target === expandBtn || e.target === visBtn) return;
        selectObject(object, name, div);
      });

      treeContainer.appendChild(div);
      domMap.set(object.uuid, { div, visBtn, expandBtn });
      return div;
    }

    // Select object and update both 3D and UI
    function selectObject(object, name, divElement) {
      // Clear previous outline and selection
      clearOutline();
      document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('selected'));
      
      // Select new object
      selectedObject = object;
      if (divElement) divElement.classList.add('selected');
      
      // Add outline if it's a mesh
      if (object.isMesh) {
        addOutline(object);
      }
      
      // Update data panel
      updateDataPanel(object, name);
    }

    // Clear outline from all objects
    function clearOutline() {
      outlineObjects.forEach(obj => {
        if (obj.isMesh && obj.userData.originalMaterial) {
          obj.material = obj.userData.originalMaterial;
          delete obj.userData.originalMaterial;
        }
        // Remove outline edge mesh if it exists
        if (obj.userData.outlineEdges) {
          obj.remove(obj.userData.outlineEdges);
          delete obj.userData.outlineEdges;
        }
      });
      outlineObjects.clear();
    }

    // Add blue outline to a mesh
    function addOutline(mesh) {
      if (!mesh.isMesh) return;
      
      outlineObjects.add(mesh);
      mesh.userData.originalMaterial = mesh.material;
      
      // Create edge geometry for outline
      const edges = new THREE.EdgesGeometry(mesh.geometry, 15); // 15 degree threshold
      const outlineLineMaterial = new THREE.LineBasicMaterial({
        color: 0x0099ff,
        linewidth: 100,
        fog: false,
        transparent: true,
        opacity: 1.0,
        depthTest: false,
        depthWrite: false
      });
      
      const outlineEdges = new THREE.LineSegments(edges, outlineLineMaterial);
      outlineEdges.renderOrder = 1;
      
      mesh.add(outlineEdges);
      mesh.userData.outlineEdges = outlineEdges;
    }

    // Recursively hide/show children in DOM and 3D scene
    function toggleChildren(parentUuid, hide) {
      const children = Array.from(document.querySelectorAll(`[data-parent="${parentUuid}"]`));
      children.forEach(childEl => {
        childEl.style.display = hide ? 'none' : '';
        const childUuid = childEl.dataset.uuid;
        const refs = domMap.get(childUuid);
        if (refs) {
          const obj = findObjectByUUID(childUuid);
          if (obj) obj.visible = visibilityState.get(obj);
        }
        // recurse
        toggleChildren(childUuid, hide);
      });
    }

    // Helper to find object in scene by UUID
    function findObjectByUUID(uuid) {
      return scene.getObjectByProperty('uuid', uuid) || null;
    }

    // Data panel update function //
    const dataPanel = document.getElementById('data-panel');
    let phaseManifestData = null;
    let dataMapData = null;
    let phaseEntries = [];

    function updateDataPanel(object, name) {
      const panel = document.getElementById('data-panel');
      
      // Find which phase this object belongs to //
      let phaseName = null;
      let phaseData = null;
      for (let entry of phaseEntries) {
        if (entry.model.getObjectByProperty('uuid', object.uuid)) {
          phaseName = entry.name;
          phaseData = phaseManifestData ? phaseManifestData[entry.name] : null;
          break;
        }
      }

      let html = `<h3>${name}</h3>`;

      // Mesh Properties
      if (object.isMesh) {
        html += `<div class="section">
          <div class="label">Type</div>
          <div class="value">Mesh</div>
        </div>`;
        
        if (object.geometry) {
          const geo = object.geometry;
          html += `<div class="section">
            <div class="label">Geometry</div>
            <div class="value">
              Vertices: ${geo.attributes.position ? geo.attributes.position.count : 'N/A'}<br>
              ${geo.index ? 'Faces: ' + (geo.index.count / 3) : ''}
            </div>
          </div>`;
        }

        if (object.material) {
          const mat = object.material;
          html += `<div class="section">
            <div class="label">Material</div>
            <div class="value">
              Type: ${mat.type}<br>
              ${mat.metalness !== undefined ? 'Metalness: ' + mat.metalness.toFixed(2) + '<br>' : ''}
              ${mat.roughness !== undefined ? 'Roughness: ' + mat.roughness.toFixed(2) : ''}
            </div>
          </div>`;
        }

        // Check for mesh-specific data in data_map.json
        if (dataMapData && dataMapData[name]) {
          html += `<div class="section">
            <div class="label">Mesh Data</div>
            <div class="value">`;
          const meshData = dataMapData[name];
          for (const [key, value] of Object.entries(meshData)) {
            html += `${key}: ${value}<br>`;
          }
          html += `</div></div>`;
        }
      } else if (object.isGroup) {
        html += `<div class="section">
          <div class="label">Type</div>
          <div class="value">Group / Node</div>
        </div>`;
      }

      // Phase info
      if (phaseName) {
        html += `<div class="section">
          <div class="label">Phase</div>
          <div class="value">${phaseName}</div>
        </div>`;

        if (phaseData) {
          html += `<div class="section">
            <div class="label">Phase Data</div>
            <div class="value">${phaseData}</div>
          </div>`;
        }
      }

      panel.innerHTML = html;
    }

    // Promise wrapper for loader
    function loadGLB(url) {
      return new Promise((resolve, reject) => {
        loader.load(url, gltf => resolve(gltf), undefined, err => reject(err));
      });
    }

    // Load Manifest & Models (promise-based so we can setup slider after all models loaded)
    loadProjectManifest(modelID).then(async (manifest) => {
      if (!manifest) return;
      treeContainer.innerHTML = '';

      // Store manifest data globally for panel updates
      phaseManifestData = manifest;

      // Load data_map.json
      try {
        const dataMapResponse = await fetch(paths.dataMap);
        if (dataMapResponse.ok) {
          dataMapData = await dataMapResponse.json();
        }
      } catch (e) {
        console.warn('Could not load data_map.json:', e);
      }

      const sortedPhases = Object.keys(manifest).sort((a, b) => {
        const numA = parseInt(a.match(/\d+/)[0]);
        const numB = parseInt(b.match(/\d+/)[0]);
        return numA - numB;
      });

      // load all models
      phaseEntries = [];
      for (let i = 0; i < sortedPhases.length; i++) {
        const phaseName = sortedPhases[i];
        const url = paths.getGLBPath(phaseName);
        try {
          const gltf = await loadGLB(url);
          const model = gltf.scene;
          scene.add(model);
          phaseEntries.push({ name: phaseName, model });
          // Build tree items for this phase (parent first, then children)
          const phaseDiv = addToSidebar(phaseName, model, 0, null);
          // recursively append children
          const build = (obj, indent, parentUuid) => {
            obj.children.forEach(child => {
              const childDiv = addToSidebar(child.name || 'Unnamed', child, indent, parentUuid);
              // ensure parent shows expand control when it has children
              if (parentUuid) {
                const parentRefs = domMap.get(parentUuid);
                if (parentRefs) {
                  parentRefs.expandBtn.classList.remove('no-children');
                  parentRefs.expandBtn.classList.add('expanded');
                }
              }
              build(child, indent + 1, child.uuid);
            });
          };
          build(model, 1, model.uuid);
        } catch (e) {
          console.error('Failed to load', url, e);
        }
      }

      // Setup phase slider
      const phaseSlider = document.getElementById('phase-slider');
      const phaseLabel = document.getElementById('phase-label');
      phaseSlider.min = 0;
      phaseSlider.max = Math.max(0, phaseEntries.length - 1);
      phaseSlider.value = phaseEntries.length - 1;
      phaseLabel.textContent = `${phaseEntries.length}`;

      function applyPhaseIndex(idx) {
        // show phases 0..idx, hide phases idx+1..
        phaseEntries.forEach((entry, i) => {
          const visible = i <= idx;
          entry.model.visible = visible;
          // update DOM items for this model and descendants
          const updateDomForObject = (obj) => {
            const refs = domMap.get(obj.uuid);
            if (refs) {
              refs.visBtn.classList.toggle('visible', visible);
              refs.visBtn.classList.toggle('hidden', !visible);
              if (visible) refs.div.classList.remove('hidden'); else refs.div.classList.add('hidden');
            }
            obj.children.forEach(c => updateDomForObject(c));
          };
          updateDomForObject(entry.model);
        });
        phaseLabel.textContent = `${idx + 1}/${phaseEntries.length}`;
      }

      applyPhaseIndex(parseInt(phaseSlider.value));
      phaseSlider.addEventListener('input', (e) => {
        applyPhaseIndex(parseInt(e.target.value));
      });
    });

    // Draggable sidebar resize
    const sidebar = document.getElementById('sidebar');
    const resizeHandle = document.getElementById('sidebar-resize-handle');
    let isResizing = false;
    
    resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const newWidth = Math.max(150, e.clientX);
        sidebar.style.width = newWidth + 'px';
        renderer.domElement.style.left = newWidth + 'px';
        renderer.setSize(window.innerWidth - newWidth, window.innerHeight);
        
        camera.aspect = (window.innerWidth - newWidth) / window.innerHeight;
        camera.updateProjectionMatrix();
    });
    
    document.addEventListener('mouseup', () => {
        isResizing = false;
    });

    // Resize Handler
    window.addEventListener('resize', () => {
        const sidebarWidth = parseInt(sidebar.style.width) || 250;
        camera.aspect = (window.innerWidth - sidebarWidth) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - sidebarWidth, window.innerHeight);
    });

    // Raycasting for 3D click selection
    renderer.domElement.addEventListener('click', (event) => {
        // Ignore clicks on sidebar or UI elements
        if (event.clientX < parseInt(sidebar.style.width || 250)) return;
        
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        const sidebarWidth = parseInt(sidebar.style.width || 250);
        mouse.x = ((event.clientX - sidebarWidth) / (window.innerWidth - sidebarWidth)) * 2 - 1;
        mouse.y = -((event.clientY) / window.innerHeight) * 2 + 1;
        
        // Update raycaster
        raycaster.setFromCamera(mouse, camera);
        
        // Find intersected objects
        const allMeshes = [];
        scene.traverse(child => {
            if (child.isMesh) allMeshes.push(child);
        });
        
        const intersects = raycaster.intersectObjects(allMeshes);
        
        if (intersects.length > 0) {
            const clickedMesh = intersects[0].object;
            // Find corresponding tree item and select it
            const treeItem = document.querySelector(`[data-uuid="${clickedMesh.uuid}"]`);
            if (treeItem) {
                selectObject(clickedMesh, clickedMesh.name, treeItem);
            }
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>